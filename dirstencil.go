package main

import (
	"bytes"
	"log"
	"os"
	"path"
	"sync"
	"text/template"

	"gopkg.in/yaml.v2"
)

type delims struct {
	Left  string `yaml:"left"`
	Right string `yaml:"right"`
}

type target struct {
	Dir  string            `yaml:"dir"`
	Vars map[string]string `yaml:"vars"`
}

type configuration struct {
	Version     int64             `yaml:"version"`
	TemplateDir string            `yaml:"template-dir"`
	Delims      delims            `yaml:"delims"`
	Targets     map[string]target `yaml:"targets"`
}

type renderer struct {
	config configuration
}

func (r *renderer) loadConfig(configFile string) {
	log.Println("Loading config from", configFile)
	file, err := os.ReadFile(configFile)
	if err != nil {
		log.Fatalf("Failed to read configuration from %s: %s", configFile, err)
	}
	var conf configuration
	err = yaml.Unmarshal(file, &conf)
	if err != nil {
		log.Fatalf("Failed to unmarshall configuraton from %s: %s", configFile, err)
	}
	log.Println("Found configuration with version", conf.Version, "and template dir", conf.TemplateDir)
	r.config = conf
}

func (r *renderer) processTarget(name string, t target) {
	log.Println("Processing target", name)
	r.processTemplateDirForTarget(name, t, r.config.TemplateDir, "")
}

func (r *renderer) processTemplateDirForTarget(name string, t target, baseDir string, subDir string) {
	targetDir := path.Join(t.Dir, subDir)
	log.Println("Ensuring dir", targetDir, "exists for", name)
	if err := os.MkdirAll(targetDir, os.ModePerm); err != nil {
		log.Fatalf("Failed to ensure existence of dir %s for %s: %s", targetDir, name, err)
	}

	dir := path.Join(baseDir, subDir)
	entries, err := os.ReadDir(dir)
	if err != nil {
		log.Fatalf("Failed to read dir %s for %s: %s", dir, name, err)
	}
	for _, entry := range entries {
		log.Println("Processing", entry.Name(), "in", dir, "for", name)
		if entry.IsDir() {
			r.processTemplateDirForTarget(name, t, baseDir, path.Join(subDir, entry.Name()))
		} else {
			r.renderTemplateForTarget(name, t, baseDir, subDir, entry.Name())
		}

	}
}

func (r *renderer) renderTemplateForTarget(name string, t target, baseDir string, subDir string, file string) {
	targetFile := path.Join(t.Dir, subDir, file)
	sourceFile := path.Join(baseDir, subDir, file)
	log.Println("Rendering", sourceFile, "to", targetFile, "for", name)

	tpl, err := template.New(file).
		Delims(r.config.Delims.Left, r.config.Delims.Right).
		ParseFiles(sourceFile)
	if err != nil {
		log.Fatalf("Failed to parse template %s for %s: %s", sourceFile, name, err)
	}

	values := t.Vars
	values["genmsg"] = "Generated by dirstencil"
	buffer := bytes.Buffer{}
	if err := tpl.Execute(&buffer, values); err != nil {
		log.Fatalf("Failed to render template %s for %s: %s", sourceFile, name, err)
	}

	f, err2 := os.Create(targetFile)
	if err2 != nil {
		log.Fatalf("Failed create target file %s for %s: %s", targetFile, name, err)
	}
	f.WriteString(buffer.String())
}

func (r *renderer) renderAll() {
	log.Println("Rendering for", len(r.config.Targets), "targets")
	wg := sync.WaitGroup{}
	for name, t := range r.config.Targets {
		wg.Add(1)
		go func() {
			defer wg.Done()
			r.processTarget(name, t)
		}()
	}
	wg.Wait()
}

func NewRenderer(configFile string) *renderer {
	r := renderer{}
	r.loadConfig(configFile)
	return &r
}

func main() {
	configFile := "dirstencil.yaml"
	r := NewRenderer(configFile)
	r.renderAll()
}
